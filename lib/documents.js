"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.generateDocument=exports.getAttachment=exports.encryptDocumentData=exports.getDocument=void 0;var _customError=_interopRequireDefault(require("./custom-error")),_encryption=require("./encryption"),_files=require("./files");function _interopRequireDefault(a){return a&&a.__esModule?a:{default:a}}const stripHex=a=>a.replace(/^(0x)/,""),parseOrganizationRawObject=a=>{const{id:b,name:c,documentIds:d,created:e}=a;return{id:b.replace(/^(0x)/,""),name:c,documentIds:d.map(a=>a.replace(/^(0x)/,"")),created:new Date(1e3*e)}},parseDocumentRawObject=a=>{const{id:b,organizationId:c,magic:d,body:e,data:f,ipfsDirectoryHash:g,pinned:h,created:i}=a;return{id:stripHex(b),organizationId:stripHex(c),magic:stripHex(d),body:e,data:JSON.parse(f),ipfsDirectoryHash:g,pinned:h,created:new Date(1e3*i)}},getOrganizationById=async(a,b)=>{try{const c=await a.methods.getOrganizationById(`0x${b}`).call();return parseOrganizationRawObject(c)}catch(a){throw console.error(a),new _customError.default("Organization not found","NONEXISTENT_ORGANIZATION")}},getDocument=async(a,b,c,d={})=>{const f={organizationDetails:!1,attachmentInformation:!1,attachedFiles:!1,// requestPassword: () => {},
wrongPasswordAlert:()=>{},...d};let g;try{g=await a.methods.getDocumentById(`0x${c}`).call()}catch(a){throw new _customError.default("Document does not exist","NONEXISTENT_DOCUMENT")}if(g.body=g.body.join(),"0x00000000000000000000000000000000"!==g.magic){if("function"!=typeof f.requestPassword)throw new _customError.default("Document is encrypted and requirePassword function was not provided");for(;;){const a=f.requestPassword();try{const[b,c,d]=(0,_encryption.decryptMultiple)([g.body,g.data,g.ipfsDirectoryHash],stripHex(g.magic),a);g.body=b,g.data=c,g.ipfsDirectoryHash=d}catch(a){f.wrongPasswordAlert()}}}const h=parseDocumentRawObject(g);if(f.organizationDetails&&(h.organization=await getOrganizationById(a,h.organizationId)),f.attachmentInformation||f.attachedFiles)if(""!==h.ipfsDirectoryHash){const a=await(0,_files.listFilesInDirectory)(b,h.ipfsDirectoryHash);if(h.attachments=a,f.attachedFiles){const c=a.map(async a=>{const{content:c}=await(0,_files.getFile)(b,a.hash);return{...a,content:c}});h.attachments=await Promise.all(c)}}else h.attachments=[];return h};exports.getDocument=getDocument;const encryptDocumentData=(a,b)=>{const{magic:c,encryptedArray:[d,e,f]}=encrypt([a.body,a.data,a.ipfsDirectoryHash],b);return{...a,magic:c,body:d,data:e,ipfsDirectoryHash:f}};exports.encryptDocumentData=encryptDocumentData;const getAttachment=(a,b)=>(0,_files.getFile)(a,b).then(a=>a.content);exports.getAttachment=getAttachment;const generateDocument=async(a,b,c,d,e,f)=>{const g={encrypted:!1,// password: '',
...f},{directory:{hash:h}}=(0,_files.saveFilesInDirectory)(b,e);let i={encrypted:g.encrypted,data:d,body:c,ipfsDirectoryHash:h};throw g.encrypted?i=encryptDocumentData(i):i.magic=Uint8Array(16),new Error("This feature is not implemented yet")};exports.generateDocument=generateDocument;
//# sourceMappingURL=documents.js.map