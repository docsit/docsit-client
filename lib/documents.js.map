{"version":3,"sources":["../src/documents.js"],"names":["stripHex","hex","replace","parseOrganizationRawObject","rawObject","id","name","documentIds","created","map","documentId","Date","parseDocumentRawObject","organizationId","magic","body","data","ipfsDirectoryHash","pinned","JSON","parse","getOrganizationById","contract","response","methods","call","err","console","error","CustomError","getDocumentById","getDocument","ipfsClient","options","finalOptions","organizationDetails","attachmentInformation","attachedFiles","wrongPasswordAlert","rawDocumentData","requestPassword","password","e","documentData","organization","attachmentsData","attachments","promiseArray","attachment","content","hash","Promise","all","encryptDocumentData","encryptedArray","encrypt","getAttachment","cid","then","file","generateDocument","encrypted","directory","Uint8Array","Error"],"mappings":";;;;;;;AAAA;;AACA;;AACA;;;;AAEA,MAAMA,QAAQ,GAAGC,GAAG,IAAIA,GAAG,CAACC,OAAJ,CAAY,OAAZ,EAAqB,EAArB,CAAxB;;AAEA,MAAMC,0BAA0B,GAAGC,SAAS,IAAI;AAC9C,QAAM;AAAEC,IAAAA,EAAF;AAAMC,IAAAA,IAAN;AAAYC,IAAAA,WAAZ;AAAyBC,IAAAA;AAAzB,MAAqCJ,SAA3C;AACA,SAAO;AACLC,IAAAA,EAAE,EAAEA,EAAE,CAACH,OAAH,CAAW,OAAX,EAAoB,EAApB,CADC;AAELI,IAAAA,IAFK;AAGLC,IAAAA,WAAW,EAAEA,WAAW,CAACE,GAAZ,CAAgBC,UAAU,IAAIA,UAAU,CAACR,OAAX,CAAmB,OAAnB,EAA4B,EAA5B,CAA9B,CAHR;AAILM,IAAAA,OAAO,EAAE,IAAIG,IAAJ,CAASH,OAAO,GAAG,IAAnB;AAJJ,GAAP;AAMD,CARD;;AAUA,MAAMI,sBAAsB,GAAGR,SAAS,IAAI;AAC1C,QAAM;AAAEC,IAAAA,EAAF;AAAMQ,IAAAA,cAAN;AAAsBC,IAAAA,KAAtB;AAA6BC,IAAAA,IAA7B;AAAmCC,IAAAA,IAAnC;AAAyCC,IAAAA,iBAAzC;AAA4DC,IAAAA,MAA5D;AAAoEV,IAAAA;AAApE,MAAgFJ,SAAtF;AACA,SAAO;AACLC,IAAAA,EAAE,EAAEL,QAAQ,CAACK,EAAD,CADP;AAELQ,IAAAA,cAAc,EAAEb,QAAQ,CAACa,cAAD,CAFnB;AAGLC,IAAAA,KAAK,EAAEd,QAAQ,CAACc,KAAD,CAHV;AAILC,IAAAA,IAJK;AAKLC,IAAAA,IAAI,EAAEG,IAAI,CAACC,KAAL,CAAWJ,IAAX,CALD;AAMLC,IAAAA,iBANK;AAOLC,IAAAA,MAPK;AAQLV,IAAAA,OAAO,EAAE,IAAIG,IAAJ,CAASH,OAAO,GAAG,IAAnB;AARJ,GAAP;AAUD,CAZD;;AAcA,MAAMa,mBAAmB,GAAG,OAAOC,QAAP,EAAiBT,cAAjB,KAAoC;AAC9D,MAAI;AACF,UAAMU,QAAQ,GAAG,MAAMD,QAAQ,CAACE,OAAT,CAAiBH,mBAAjB,CAAsC,KAAIR,cAAe,EAAzD,EAA4DY,IAA5D,EAAvB;AACA,WAAOtB,0BAA0B,CAACoB,QAAD,CAAjC;AACD,GAHD,CAGE,OAAOG,GAAP,EAAY;AACZC,IAAAA,OAAO,CAACC,KAAR,CAAcF,GAAd;AACA,UAAM,IAAIG,oBAAJ,CAAgB,wBAAhB,EAA0C,0BAA1C,CAAN;AACD;AACF,CARD;;AAUA,MAAMC,eAAe,GAAG,OAAOR,QAAP,EAAiBZ,UAAjB,KAAgC;AACtD,MAAI;AACF,UAAMa,QAAQ,GAAG,MAAMD,QAAQ,CAACE,OAAT,CAAiBM,eAAjB,CAAkC,KAAIpB,UAAW,EAAjD,EAAoDe,IAApD,EAAvB;AACA,WAAOb,sBAAsB,CAACW,QAAD,CAA7B;AACD,GAHD,CAGE,OAAOG,GAAP,EAAY;AACZC,IAAAA,OAAO,CAACC,KAAR,CAAcF,GAAd;AACA,UAAM,IAAIG,oBAAJ,CAAgB,oBAAhB,EAAsC,sBAAtC,CAAN;AACD;AACF,CARD;;AAUO,MAAME,WAAW,GAAG,OAAOT,QAAP,EAAiBU,UAAjB,EAA6B3B,EAA7B,EAAiC4B,OAAO,GAAG,EAA3C,KAAkD;AAC3E,QAAMC,YAAY,GAAG;AACnBC,IAAAA,mBAAmB,EAAE,KADF;AAEnBC,IAAAA,qBAAqB,EAAE,KAFJ;AAGnBC,IAAAA,aAAa,EAAE,KAHI;AAInB;AACAC,IAAAA,kBAAkB,EAAE,MAAM,CAAE,CALT;AAMnB,OAAGL;AANgB,GAArB;AASA,MAAIM,eAAJ;;AACA,MAAI;AACFA,IAAAA,eAAe,GAAG,MAAMjB,QAAQ,CAACE,OAAT,CAAiBM,eAAjB,CAAkC,KAAIzB,EAAG,EAAzC,EAA4CoB,IAA5C,EAAxB;AACD,GAFD,CAEE,OAAOC,GAAP,EAAY;AACZ,UAAM,IAAIG,oBAAJ,CAAgB,yBAAhB,EAA2C,sBAA3C,CAAN;AACD;;AAED,MAAIU,eAAe,CAACzB,KAAhB,KAA0B,oCAA9B,EAAoE;AAClE,QAAI,OAAOoB,YAAY,CAACM,eAApB,KAAwC,UAA5C,EACE,MAAM,IAAIX,oBAAJ,CAAgB,qEAAhB,CAAN;;AACF,WAAO,IAAP,EAAa;AACX,YAAMY,QAAQ,GAAGP,YAAY,CAACM,eAAb,EAAjB;;AACA,UAAI;AACF,cAAM,CAACzB,IAAD,EAAOC,IAAP,EAAaC,iBAAb,IAAkC,iCACtC,CAACsB,eAAe,CAACxB,IAAjB,EAAuBwB,eAAe,CAACvB,IAAvC,EAA6CuB,eAAe,CAACtB,iBAA7D,CADsC,EAEtCjB,QAAQ,CAACuC,eAAe,CAACzB,KAAjB,CAF8B,EAGtC2B,QAHsC,CAAxC;AAKAF,QAAAA,eAAe,CAACxB,IAAhB,GAAuBA,IAAvB;AACAwB,QAAAA,eAAe,CAACvB,IAAhB,GAAuBA,IAAvB;AACAuB,QAAAA,eAAe,CAACtB,iBAAhB,GAAoCA,iBAApC;AACD,OATD,CASE,OAAOyB,CAAP,EAAU;AACVR,QAAAA,YAAY,CAACI,kBAAb;AACD;AACF;AACF;;AAED,QAAMK,YAAY,GAAG/B,sBAAsB,CAAC2B,eAAD,CAA3C;;AAEA,MAAIL,YAAY,CAACC,mBAAjB,EAAsC;AACpCQ,IAAAA,YAAY,CAACC,YAAb,GAA4B,MAAMvB,mBAAmB,CAACC,QAAD,EAAWqB,YAAY,CAAC9B,cAAxB,CAArD;AACD;;AACD,MAAIqB,YAAY,CAACE,qBAAb,IAAsCF,YAAY,CAACG,aAAvD,EAAsE;AACpE,UAAMQ,eAAe,GAAG,MAAM,iCAAqBb,UAArB,EAAiCW,YAAY,CAAC1B,iBAA9C,CAA9B;AACA0B,IAAAA,YAAY,CAACG,WAAb,GAA2BD,eAA3B;;AACA,QAAIX,YAAY,CAACG,aAAjB,EAAgC;AAC9B,YAAMU,YAAY,GAAGF,eAAe,CAACpC,GAAhB,CAAoB,MAAMuC,UAAN,IAAoB;AAC3D,cAAM;AAAEC,UAAAA;AAAF,YAAc,MAAM,oBAAQjB,UAAR,EAAoBgB,UAAU,CAACE,IAA/B,CAA1B;AACA,eAAO,EACL,GAAGF,UADE;AAELC,UAAAA;AAFK,SAAP;AAID,OANoB,CAArB;AAOAN,MAAAA,YAAY,CAACG,WAAb,GAA2B,MAAMK,OAAO,CAACC,GAAR,CAAYL,YAAZ,CAAjC;AACD;AACF;;AACD,SAAOJ,YAAP;AACD,CAzDM;;;;AA2DA,MAAMU,mBAAmB,GAAG,CAACV,YAAD,EAAeF,QAAf,KAA4B;AAC7D,QAAM;AACJ3B,IAAAA,KADI;AAEJwC,IAAAA,cAAc,EAAE,CAACvC,IAAD,EAAOC,IAAP,EAAaC,iBAAb;AAFZ,MAGFsC,OAAO,CAAC,CAACZ,YAAY,CAAC5B,IAAd,EAAoB4B,YAAY,CAAC3B,IAAjC,EAAuC2B,YAAY,CAAC1B,iBAApD,CAAD,EAAyEwB,QAAzE,CAHX;AAIA,SAAO,EACL,GAAGE,YADE;AAEL7B,IAAAA,KAFK;AAGLC,IAAAA,IAHK;AAILC,IAAAA,IAJK;AAKLC,IAAAA;AALK,GAAP;AAOD,CAZM;;;;AAcA,MAAMuC,aAAa,GAAG,CAACxB,UAAD,EAAayB,GAAb,KAC3B,oBAAQzB,UAAR,EAAoByB,GAApB,EAAyBC,IAAzB,CAA8BC,IAAI,IAAIA,IAAI,CAACV,OAA3C,CADK;;;;AAGA,MAAMW,gBAAgB,GAAG,OAAOtC,QAAP,EAAiBU,UAAjB,EAA6BjB,IAA7B,EAAmCC,IAAnC,EAAyC8B,WAAzC,EAAsDb,OAAtD,KAAkE;AAChG,QAAMC,YAAY,GAAG;AACnB2B,IAAAA,SAAS,EAAE,KADQ;AAEnB;AACA,OAAG5B;AAHgB,GAArB;AAKA,QAAM;AACJ6B,IAAAA,SAAS,EAAE;AAAEZ,MAAAA,IAAI,EAAEjC;AAAR;AADP,MAEF,iCAAqBe,UAArB,EAAiCc,WAAjC,CAFJ;AAGA,MAAIH,YAAY,GAAG;AACjBkB,IAAAA,SAAS,EAAE3B,YAAY,CAAC2B,SADP;AAEjB7C,IAAAA,IAFiB;AAGjBD,IAAAA,IAHiB;AAIjBE,IAAAA;AAJiB,GAAnB;;AAMA,MAAIiB,YAAY,CAAC2B,SAAjB,EAA4B;AAC1BlB,IAAAA,YAAY,GAAGU,mBAAmB,CAACV,YAAD,CAAlC;AACD,GAFD,MAEO;AACLA,IAAAA,YAAY,CAAC7B,KAAb,GAAqBiD,UAAU,CAAC,EAAD,CAA/B;AACD;;AACD,QAAM,IAAIC,KAAJ,CAAU,qCAAV,CAAN;AACD,CArBM","sourcesContent":["import CustomError from './custom-error';\nimport { hexToArrayBuffer, decryptMultiple, encryptMultiple } from './encryption';\nimport { listFilesInDirectory, getFile, saveFilesInDirectory } from './files';\n\nconst stripHex = hex => hex.replace(/^(0x)/, '');\n\nconst parseOrganizationRawObject = rawObject => {\n  const { id, name, documentIds, created } = rawObject;\n  return {\n    id: id.replace(/^(0x)/, ''),\n    name,\n    documentIds: documentIds.map(documentId => documentId.replace(/^(0x)/, '')),\n    created: new Date(created * 1000),\n  };\n};\n\nconst parseDocumentRawObject = rawObject => {\n  const { id, organizationId, magic, body, data, ipfsDirectoryHash, pinned, created } = rawObject;\n  return {\n    id: stripHex(id),\n    organizationId: stripHex(organizationId),\n    magic: stripHex(magic),\n    body,\n    data: JSON.parse(data),\n    ipfsDirectoryHash,\n    pinned,\n    created: new Date(created * 1000),\n  };\n};\n\nconst getOrganizationById = async (contract, organizationId) => {\n  try {\n    const response = await contract.methods.getOrganizationById(`0x${organizationId}`).call();\n    return parseOrganizationRawObject(response);\n  } catch (err) {\n    console.error(err);\n    throw new CustomError('Organization not found', 'NONEXISTENT_ORGANIZATION');\n  }\n};\n\nconst getDocumentById = async (contract, documentId) => {\n  try {\n    const response = await contract.methods.getDocumentById(`0x${documentId}`).call();\n    return parseDocumentRawObject(response);\n  } catch (err) {\n    console.error(err);\n    throw new CustomError('Document not found', 'NONEXISTENT_DOCUMENT');\n  }\n};\n\nexport const getDocument = async (contract, ipfsClient, id, options = {}) => {\n  const finalOptions = {\n    organizationDetails: false,\n    attachmentInformation: false,\n    attachedFiles: false,\n    // requestPassword: () => {},\n    wrongPasswordAlert: () => {},\n    ...options,\n  };\n\n  let rawDocumentData;\n  try {\n    rawDocumentData = await contract.methods.getDocumentById(`0x${id}`).call();\n  } catch (err) {\n    throw new CustomError('Document does not exist', 'NONEXISTENT_DOCUMENT');\n  }\n\n  if (rawDocumentData.magic !== '0x00000000000000000000000000000000') {\n    if (typeof finalOptions.requestPassword !== 'function')\n      throw new CustomError('Document is encrypted and requirePassword function was not provided');\n    while (true) {\n      const password = finalOptions.requestPassword();\n      try {\n        const [body, data, ipfsDirectoryHash] = decryptMultiple(\n          [rawDocumentData.body, rawDocumentData.data, rawDocumentData.ipfsDirectoryHash],\n          stripHex(rawDocumentData.magic),\n          password\n        );\n        rawDocumentData.body = body;\n        rawDocumentData.data = data;\n        rawDocumentData.ipfsDirectoryHash = ipfsDirectoryHash;\n      } catch (e) {\n        finalOptions.wrongPasswordAlert();\n      }\n    }\n  }\n\n  const documentData = parseDocumentRawObject(rawDocumentData);\n\n  if (finalOptions.organizationDetails) {\n    documentData.organization = await getOrganizationById(contract, documentData.organizationId);\n  }\n  if (finalOptions.attachmentInformation || finalOptions.attachedFiles) {\n    const attachmentsData = await listFilesInDirectory(ipfsClient, documentData.ipfsDirectoryHash);\n    documentData.attachments = attachmentsData;\n    if (finalOptions.attachedFiles) {\n      const promiseArray = attachmentsData.map(async attachment => {\n        const { content } = await getFile(ipfsClient, attachment.hash);\n        return {\n          ...attachment,\n          content,\n        };\n      });\n      documentData.attachments = await Promise.all(promiseArray);\n    }\n  }\n  return documentData;\n};\n\nexport const encryptDocumentData = (documentData, password) => {\n  const {\n    magic,\n    encryptedArray: [body, data, ipfsDirectoryHash],\n  } = encrypt([documentData.body, documentData.data, documentData.ipfsDirectoryHash], password);\n  return {\n    ...documentData,\n    magic,\n    body,\n    data,\n    ipfsDirectoryHash,\n  };\n};\n\nexport const getAttachment = (ipfsClient, cid) =>\n  getFile(ipfsClient, cid).then(file => file.content);\n\nexport const generateDocument = async (contract, ipfsClient, body, data, attachments, options) => {\n  const finalOptions = {\n    encrypted: false,\n    // password: '',\n    ...options,\n  };\n  const {\n    directory: { hash: ipfsDirectoryHash },\n  } = saveFilesInDirectory(ipfsClient, attachments);\n  let documentData = {\n    encrypted: finalOptions.encrypted,\n    data,\n    body,\n    ipfsDirectoryHash,\n  };\n  if (finalOptions.encrypted) {\n    documentData = encryptDocumentData(documentData);\n  } else {\n    documentData.magic = Uint8Array(16);\n  }\n  throw new Error('This feature is not implemented yet');\n};\n"],"file":"documents.js"}