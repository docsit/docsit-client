{"version":3,"sources":["../src/documents.js"],"names":["stripHex","hex","replace","parseOrganizationRawObject","rawObject","id","name","documentIds","created","map","documentId","Date","parseDocumentRawObject","organizationId","magic","body","data","ipfsDirectoryHash","pinned","JSON","parse","getOrganizationById","contract","response","methods","call","err","console","error","CustomError","getDocument","ipfsClient","options","finalOptions","organizationDetails","attachmentInformation","attachedFiles","wrongPasswordAlert","rawDocumentData","getDocumentById","join","requestPassword","password","e","documentData","organization","attachmentsData","attachments","promiseArray","attachment","content","hash","Promise","all","encryptDocumentData","encryptedArray","encrypt","getAttachment","cid","then","file","generateDocument","encrypted","directory","Uint8Array","Error"],"mappings":"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","sourcesContent":["import CustomError from './custom-error';\nimport { hexToArrayBuffer, decryptMultiple, encryptMultiple } from './encryption';\nimport { listFilesInDirectory, getFile, saveFilesInDirectory } from './files';\n\nconst stripHex = hex => hex.replace(/^(0x)/, '');\n\nconst parseOrganizationRawObject = rawObject => {\n  const { id, name, documentIds, created } = rawObject;\n  return {\n    id: id.replace(/^(0x)/, ''),\n    name,\n    documentIds: documentIds.map(documentId => documentId.replace(/^(0x)/, '')),\n    created: new Date(created * 1000),\n  };\n};\n\nconst parseDocumentRawObject = rawObject => {\n  const { id, organizationId, magic, body, data, ipfsDirectoryHash, pinned, created } = rawObject;\n  return {\n    id: stripHex(id),\n    organizationId: stripHex(organizationId),\n    magic: stripHex(magic),\n    body,\n    data: JSON.parse(data),\n    ipfsDirectoryHash,\n    pinned,\n    created: new Date(created * 1000),\n  };\n};\n\nconst getOrganizationById = async (contract, organizationId) => {\n  try {\n    const response = await contract.methods.getOrganizationById(`0x${organizationId}`).call();\n    return parseOrganizationRawObject(response);\n  } catch (err) {\n    console.error(err);\n    throw new CustomError('Organization not found', 'NONEXISTENT_ORGANIZATION');\n  }\n};\n\nexport const getDocument = async (contract, ipfsClient, id, options = {}) => {\n  const finalOptions = {\n    organizationDetails: false,\n    attachmentInformation: false,\n    attachedFiles: false,\n    // requestPassword: () => {},\n    wrongPasswordAlert: () => {},\n    ...options,\n  };\n\n  let rawDocumentData;\n  try {\n    rawDocumentData = await contract.methods.getDocumentById(`0x${id}`).call();\n  } catch (err) {\n    throw new CustomError('Document does not exist', 'NONEXISTENT_DOCUMENT');\n  }\n\n  rawDocumentData.body = rawDocumentData.body.join();\n\n  if (rawDocumentData.magic !== '0x00000000000000000000000000000000') {\n    if (typeof finalOptions.requestPassword !== 'function')\n      throw new CustomError('Document is encrypted and requirePassword function was not provided');\n    while (true) {\n      const password = finalOptions.requestPassword();\n      try {\n        const [body, data, ipfsDirectoryHash] = decryptMultiple(\n          [rawDocumentData.body, rawDocumentData.data, rawDocumentData.ipfsDirectoryHash],\n          stripHex(rawDocumentData.magic),\n          password\n        );\n        rawDocumentData.body = body;\n        rawDocumentData.data = data;\n        rawDocumentData.ipfsDirectoryHash = ipfsDirectoryHash;\n      } catch (e) {\n        finalOptions.wrongPasswordAlert();\n      }\n    }\n  }\n\n  const documentData = parseDocumentRawObject(rawDocumentData);\n\n  if (finalOptions.organizationDetails) {\n    documentData.organization = await getOrganizationById(contract, documentData.organizationId);\n  }\n  if (finalOptions.attachmentInformation || finalOptions.attachedFiles) {\n    if (documentData.ipfsDirectoryHash !== '') {\n      const attachmentsData = await listFilesInDirectory(\n        ipfsClient,\n        documentData.ipfsDirectoryHash\n      );\n      documentData.attachments = attachmentsData;\n      if (finalOptions.attachedFiles) {\n        const promiseArray = attachmentsData.map(async attachment => {\n          const { content } = await getFile(ipfsClient, attachment.hash);\n          return {\n            ...attachment,\n            content,\n          };\n        });\n        documentData.attachments = await Promise.all(promiseArray);\n      }\n    } else {\n      documentData.attachments = [];\n    }\n  }\n  return documentData;\n};\n\nexport const encryptDocumentData = (documentData, password) => {\n  const {\n    magic,\n    encryptedArray: [body, data, ipfsDirectoryHash],\n  } = encrypt([documentData.body, documentData.data, documentData.ipfsDirectoryHash], password);\n  return {\n    ...documentData,\n    magic,\n    body,\n    data,\n    ipfsDirectoryHash,\n  };\n};\n\nexport const getAttachment = (ipfsClient, cid) =>\n  getFile(ipfsClient, cid).then(file => file.content);\n\nexport const generateDocument = async (contract, ipfsClient, body, data, attachments, options) => {\n  const finalOptions = {\n    encrypted: false,\n    // password: '',\n    ...options,\n  };\n  const {\n    directory: { hash: ipfsDirectoryHash },\n  } = saveFilesInDirectory(ipfsClient, attachments);\n  let documentData = {\n    encrypted: finalOptions.encrypted,\n    data,\n    body,\n    ipfsDirectoryHash,\n  };\n  if (finalOptions.encrypted) {\n    documentData = encryptDocumentData(documentData);\n  } else {\n    documentData.magic = Uint8Array(16);\n  }\n  throw new Error('This feature is not implemented yet');\n};\n"],"file":"documents.js"}